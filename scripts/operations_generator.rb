#!/usr/bin/env ruby

n = 3

def make_map(name, in_arity, out_arity, out_type_wrapper)
  in_type_names = ('A'..'H').to_a[0...in_arity]
  out_type_names = ('S'..'Z').to_a[0...out_arity]
  in_type = type_of(in_type_names)
  out_type = type_of(out_type_names)
  in_converter = if in_arity == 1 then 'fieldToFields' else 'productToFields' end
  out_converter = if out_arity == 1 then 'fieldToFields' else 'productToFields' end

    "  def #{name}[#{in_type_names.join(',')},#{out_type_names.join(',')}]" +
    "(fs : (#{fields_of(in_type_names)},#{fields_of(out_type_names)}))" +
    "(fn : (#{in_type}) => #{out_type_wrapper.call(out_type)})" +
    %Q|
    (implicit conv : TupleConverter[#{in_type}], setter : TupleSetter[#{out_type}], inArity : Arity#{in_arity}, outArity : Arity#{out_arity}): Pipe = {

      #{name}(#{in_converter}(fs._1) -> #{out_converter}(fs._2))(fn)(conv, setter)

  }

|
end

def fields_of(type_names)

  fields = type_names.map { |type| "Field[" + type + "]" }.join(',')
  fields = "(" + fields + ")" if type_names.size > 1
  fields

end

def type_of(type_names)

  type = type_names.join(',')
  type = "(" + type + ")" if type_names.size > 1
  type

end

puts "// following were autogenerated by #{__FILE__} at #{Time.now} do not edit"
puts %q|package com.twitter.scalding

import cascading.pipe.Pipe
import cascading.tuple.Fields

trait GeneratedRichPipeOperations extends FieldConversions {

|

ordinary_map = lambda { |type| type }
flat_map = lambda { |type| "Iterable[#{type}]" }
map_info = [['map', ordinary_map], ['mapTo', ordinary_map], ['flatMap', flat_map], ['flatMapTo', flat_map]]

map_info.each { |info|

  name = info[0]
  wrapper = info[1]
  puts "  def #{name}[A,T](fs : (Fields,Fields))(fn : A => #{wrapper.call('T')})"
  puts "    (implicit conv : TupleConverter[A], setter : TupleSetter[T]) : Pipe"
  puts ""

  (1..n).each { |in_arity|
    (1..n).each { |out_arity|
      puts make_map(name, in_arity, out_arity, wrapper)
    }
  }
}

puts %q|}

sealed case class Arity private[scalding](arity: Int)
|

(1..n).each { |arity| puts "sealed class Arity#{arity} private[scalding] extends Arity(#{arity})" }

puts %q|
trait Arities {

|

(1..n).each { |arity| puts "  implicit val arity#{arity} = new Arity#{arity}" }

puts %q|
}
|

puts "// end of autogenerated"
